package net.cropsense.bso3;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.vecmath.Color3f;
import javax.vecmath.Matrix4d;

import de.grogra.graph.Cache.Entry;
import de.grogra.graph.ContextDependent;
import de.grogra.graph.Graph;
import de.grogra.graph.GraphState;
import de.grogra.graph.impl.Edge;
import de.grogra.graph.impl.Node;
import de.grogra.imp3d.Polygonizable;
import de.grogra.imp3d.Polygonization;
import de.grogra.imp3d.RenderState;
import de.grogra.imp3d.Renderable;
import de.grogra.imp3d.objects.Attributes;
import de.grogra.imp3d.objects.Box;
import de.grogra.imp3d.objects.Cone;
import de.grogra.imp3d.objects.Cylinder;
import de.grogra.imp3d.objects.Frustum;
import de.grogra.imp3d.objects.GlobalTransformation;
import de.grogra.imp3d.objects.PolygonMesh;
import de.grogra.imp3d.objects.ShadedNull;
import de.grogra.imp3d.objects.Sphere;
import de.grogra.imp3d.objects.Line;
import de.grogra.imp3d.objects.Point;
import de.grogra.imp3d.shading.RGBAShader;
import de.grogra.xl.util.FloatList;
import de.grogra.xl.util.IntList;

/**
 * Base class for complex objects generated by Boolean Set Operations. <br />
 * <br />
 * Every BSO object inserted into the graph searches for all the geometric
 * primitives reachable and executes the desired operation. For unions and
 * intersections all found primitives are unified or intersected respectively.
 * For differences all primitives following the first found one are subtracted
 * from the first one or each next primitives is subtracted by the previous one.
 * If another BSO is found, its result is computed and then used as an operand
 * for the current BSO.
 * 
 * @author Florian Schoeler, Patrick Kaster
 */
@SuppressWarnings("unchecked")
public class BSO extends ShadedNull implements Renderable, Serializable,
		Polygonizable, ContextDependent
{
	private static final long serialVersionUID = -7848451215620853163L;

	/**
	 * The type of operation chosen for this BSO.
	 */
	private CSGNodeType type;

	/**
	 * The color to draw this BSO with.
	 */
	private Color3f color;

	private CSGNode root;
	private IntList indexData;
	private FloatList vertexData;
	
	/* critical edges to debug */
	private List<Line> edgesIMP3D;
	private List<Point> verticesIMP3D;

	/**
	 * Constructs a new BSO with the given operation type and color.
	 * 
	 * @param type
	 *            The type of operation for this BSO.
	 * @param color
	 *            The color to draw this BSO with.
	 */
	public BSO(CSGNodeType type, Color3f color)
	{
		setType(type);
		this.color = color;
		indexData = new IntList();
		vertexData = new FloatList();
		
		this.edgesIMP3D = new ArrayList<Line>();
		this.verticesIMP3D = new ArrayList<Point>();
	}

	/**
	 * Constructs a new BSO with the given operation type and color.
	 * 
	 * @param type
	 *            The type of operation for this BSO.
	 */
	public BSO(CSGNodeType type)
	{
		this(type, new Color3f());
		this.edgesIMP3D = new ArrayList<Line>();
	}

	/**
	 * Constructs a new BSO with the union operation and black as the color.
	 */
	public BSO()
	{
		this(CSGNodeType.Addition, new Color3f());
	}

	public IntList getIndices()
	{
		return indexData;
	}

	public FloatList getVertices()
	{
		return vertexData;
	}

	/**
	 * Returns the type of operation for this BSO.
	 * 
	 * @return The type of operation for this BSO.
	 */
	public CSGNodeType getType()
	{
		return type;
	}

	/**
	 * Sets the type of operation to the given value.
	 * 
	 * @param type
	 *            The new type of operation for this BSO.
	 * @throws IllegalArgumentException
	 *             If the given type is not valid.
	 */
	public void setType(CSGNodeType type)
	{
		this.type = type;
	}
	
	/**
	 *	set number of planes enclosing a sphere object, i.e. sampling of spheres.
	 *
	 * @param n number of planes enclosing a sphere. Bigger n means finer sampling of sphere
	 * and more time complexity of algorithm.
	 */
	public void setPlanesSamplingSphere(int n)
	{
		VarsConstants.PlanesSamplingSpheres = n;
	}
	
	/**
	 *	set number of planes enclosing a cone object, i.e. sampling of cones.
	 *
	 * @param n number of planes enclosing a cone. Bigger n means finer sampling of cone
	 * and more time complexity of algorithm.
	 */
	public void setPlanesSamplingCone(int n)
	{
		VarsConstants.PlanesSamplingCones = n;
	}

	/**
	 * Recursively applies the appropriate operation with respect to the chosen
	 * type. Wrapper function with standard arguments.
	 */
	public void apply()
	{
		apply(false, 0.0, 0.0, true);
	}
	
	/**
	 * Recursively applies the appropriate operation with respect to the chosen
	 * type.
	 */
	public void apply(boolean filter, double PointOnLineTolerance, double DistanceEpsilonWelding, boolean visibility)
	{
		VarsConstants.PointOnLineTolerance = PointOnLineTolerance;
		VarsConstants.DistanceEpsilonWelding = DistanceEpsilonWelding;
		
		indexData.clear();
		vertexData.clear();

		root = generateCSGTree();

		CSGUtility.UpdateBounds(root);
		List<CSGNode> nodes = new ArrayList<CSGNode>();
		nodes.add(root);
		KVPairs<CSGNode, CSGMesh> a = CSGCategorization.ProcessCSGNodes(root,
				nodes);
		Triangulator3 triangulator = new Triangulator3();
		
		List<HalfEdge> boundaryEdges = new ArrayList<HalfEdge>();
		List<HalfEdge> weldedEdges = new ArrayList<HalfEdge>();
		List<Vector3> boundaryVertices = new ArrayList<Vector3>();
		

		List<HalfEdge> Edges = null;
		List<Vector3> Vertices = null;
		List<Integer> visiblePolygonsIndices = new ArrayList<Integer>();
		List<Integer> invisiblePolygonsIndices = new ArrayList<Integer>();
		
		for (CSGNode key : a.keys())
		{
			CSGMesh mesh = a.get(key);
			
			if ( filter ) mesh.filterMesh3();
			
			List<Polygon> polygons = mesh.Polygons;
			List<HalfEdge> edges = mesh.Edges;
			List<Vector3> vertices = mesh.Vertices;
			Plane[] planes = mesh.Planes;
			
			Edges = edges;
			Vertices = vertices;
					
			int pointCount = 0;
			
			int k = 0;
			
			for (Polygon polygon : polygons)
			{
				if (polygon.Visible == visibility )
				{
					visiblePolygonsIndices.add(k);
					++k;
					
					triangulator.reset();
					int firstEdgeIndex = polygon.FirstIndex;
					HalfEdge firstEdge = edges.get(firstEdgeIndex);
					Vector3 firstVertex = vertices.get(firstEdge.VertexIndex);
					triangulator.addPoint(firstVertex.X, firstVertex.Y,
							firstVertex.Z);

					HalfEdge currentEdge = edges.get(firstEdge.NextIndex);
					while (firstEdge != currentEdge)
					{
						if ( isBoundaryEdge(currentEdge, edges, polygons) ) boundaryEdges.add(currentEdge); 
						Vector3 vertex = vertices.get(currentEdge.VertexIndex);
						triangulator.addPoint(vertex.X, vertex.Y, vertex.Z);
						currentEdge = edges.get(currentEdge.NextIndex);
					} 
					
					Plane polygonsPlane = planes[polygon.PlaneIndex];  
					triangulator.triangulate(polygonsPlane.Normal());
					List<Integer> indices = triangulator.getIndices();

					for (Integer i : indices)
					{
						indexData.add(pointCount++);
						Vector3 vertex = triangulator.getInputPoint(i);
						vertexData.add((float) vertex.X);
						vertexData.add((float) vertex.Y);
						vertexData.add((float) vertex.Z);
					}
				}
				else
				{
					invisiblePolygonsIndices.add(k);
					++k;
				}
			}
			System.out.println("#of polygons: "+polygons.size());
			System.out.println(); System.out.println();
			if ( filter ) boundaryEdges = mesh.boundaryEdges;
		}
		
		System.out.println("#of boundary edges: "+boundaryEdges.size());
		
		//outputBoundaryEdges(boundaryEdges, Edges, Vertices);*/
		
		Color3f red = new Color3f(255, 0, 0);
		convertEdgesToIMP3d(this.edgesIMP3D, boundaryEdges, Edges, Vertices, red);
	}

	/**
	 * Applies the selected standard operation to all reachable primitives and
	 * BSOs. The method gathers all primitives and BSOs by traversing the graph.
	 */
	private CSGNode generateCSGTree()
	{
		CSGNode root = null;
		List<Node> children = getCSGChildren(this);
		if (children.size() > 1)
		{
			root = combineChildren(this);
		} else if (children.size() == 1)
		{
			root = followPath(this, type);
		}

		return root;
	}

	private CSGNode combineChildren(BSO n)
	{
		CSGNode result = null;
		List<CSGNode> nodes = getNodesForChildren(n);
		if (nodes.size() == 1)
		{
			result = nodes.get(0);
		} else if (nodes.size() > 1)
		{
			CSGNode op_init = new CSGNode("op", n.getType(), nodes.get(0),
					nodes.get(1));
			CSGNode old_op = op_init;
			for (int i = 2; i < nodes.size(); i++)
			{
				CSGNode op = new CSGNode("op", n.getType(), old_op, nodes
						.get(i));
				old_op = op;
			}
			result = old_op;
		}

		return result;
	}

	private List<CSGNode> getNodesForChildren(BSO n)
	{
		List<CSGNode> result = new ArrayList<CSGNode>();
		List<Node> bsoChildren = getCSGChildren(n);

		for (Node child : bsoChildren)
		{
			if (child instanceof BSO)
			{
				result.add(followPath((BSO) child, ((BSO) child).getType()));
			} else
			{
				result.add(followPath(child, n.getType()));
			}
		}
		return result;
	}

	private CSGNode followPath(Node start, CSGNodeType type)
	{
		CSGNode result = null;

		List<Node> children = getCSGChildren(start);
		while (!children.isEmpty())
		{
			Node currentChild = children.remove(0);
			List<Node> currentChildren = getCSGChildren(currentChild);
			for (int i = currentChildren.size() - 1; i >= 0; --i)
			{
				children.add(0, currentChildren.get(i));
			}

			if (currentChild instanceof BSO)
			{
				List<Node> bsoChildren = getCSGChildren(currentChild);
				if (bsoChildren.size() == 1)
				{
					CSGNode res = followPath((BSO) currentChild,
							((BSO) currentChild).getType());
					CSGNode op = new CSGNode("op", type, result, res);
					result = op;
				} else if (bsoChildren.size() > 1)
				{
					CSGNode res = combineChildren((BSO) currentChild);
					CSGNode op = new CSGNode("op", type, result, res);
					result = op;
				}
				return result;
			} else
			{
				if (result == null)
				{
					if (start instanceof Box || start instanceof Cone
							|| start instanceof Cylinder
							|| start instanceof Frustum
							|| start instanceof Sphere)
					{
						result = new CSGNode("op", type, Transformer
								.getNodeFor(start), Transformer
								.getNodeFor(currentChild));
					} else
					{
						result = Transformer.getNodeFor(currentChild);
					}
				} else
				{
					CSGNode op = new CSGNode("op", type, result, Transformer
							.getNodeFor(currentChild));
					result = op;
				}
			}
		}

		return result;
	}

	public void draw(Object object, boolean asNode, RenderState rs)
	{
		if (!indexData.isEmpty() && !vertexData.isEmpty())
		{
			Matrix4d trans = GlobalTransformation.get(this, true,
					getCurrentGraphState(), true).toMatrix4d();
			trans.invert();
			rs.drawPolygons(this, object, asNode, new RGBAShader(color.x,
					color.y, color.z), 0, trans);
		}
	}

	public ContextDependent getPolygonizableSource(GraphState gs)
	{
		return this;
	}

	public Polygonization getPolygonization()
	{
		PolygonMesh polys = new PolygonMesh();
		if (!indexData.isEmpty() && !vertexData.isEmpty())
		{
			// apply();

			polys.setIndexData(indexData);
			polys.setVertexData(vertexData);
		}
		return polys;
	}

	public boolean dependsOnContext()
	{
		return false;
	}

	public void writeStamp(Entry cache, GraphState gs)
	{
	}

	public static final NType $TYPE;

	private static final class _Field extends NType.Field
	{
		private final int id;

		_Field(String name, int modifiers, de.grogra.reflect.Type type,
				de.grogra.reflect.Type componentType, int id)
		{
			super(BSO.$TYPE, name, modifiers, type, componentType);
			this.id = id;
		}
	}

	static
	{
		$TYPE = new NType(new BSO());
		$TYPE.addIdentityAccessor(Attributes.SHAPE);
		$TYPE.validate();
	}

	@Override
	protected NType getNTypeImpl()
	{
		return $TYPE;
	}

	@Override
	protected de.grogra.graph.impl.Node newInstance()
	{
		return new BSO();
	}

	public int getDirectChildCount(Node n)
	{
		int result = 0;
		for (Edge e = n.getFirstEdge(); e != null; e = e.getNext(n))
		{
			if (e.isSource(n)
					&& (e.getEdgeBits() == Graph.SUCCESSOR_EDGE || e
							.getEdgeBits() == Graph.BRANCH_EDGE))
			{
				result++;
			}
		}
		return result;
	}

	public List<Node> getDirectChildren(Node n)
	{
		List<Node> children = new ArrayList<Node>();
		for (Edge e = n.getFirstEdge(); e != null; e = e.getNext(n))
		{
			if (e.isSource(n)
					&& (e.getEdgeBits() == Graph.SUCCESSOR_EDGE || e
							.getEdgeBits() == Graph.BRANCH_EDGE))
			{
				children.add(e.getTarget());
			}
		}
		return children;
	}

	public List<Node> getCSGChildren(Node n)
	{
		if (n == null)
			throw new IllegalArgumentException("n must not be null.");

		List<Node> result = new ArrayList<Node>();
		List<Node> currentChildren = getDirectChildren(n);
		while (!currentChildren.isEmpty())
		{
			Node currentChild = currentChildren.remove(0);
			if (currentChild instanceof Box || currentChild instanceof Cone
					|| currentChild instanceof Cylinder
					|| currentChild instanceof Frustum
					|| currentChild instanceof Sphere
					|| currentChild instanceof BSO)
			{
				if (result.isEmpty())
					result.add(currentChild);
				else
					result.add(result.size() - 1, currentChild);
			} else
			{
				List<Node> tempChildren = getDirectChildren(currentChild);
				if (tempChildren.size() > 0)
				{
					for (int i = tempChildren.size() - 1; i >= 0; --i)
					{
						currentChildren.add(0, tempChildren.get(i));
					}
				}
			}
		}

		return result;
	}
	
	private boolean isBoundaryEdge(HalfEdge check, List<HalfEdge> edges, List<Polygon> polygons)
	{
		int twinIndex = check.TwinIndex;
		HalfEdge twin = edges.get(twinIndex);
		
		int polygonIndex = twin.PolygonIndex;
		
		//System.out.println("twinIndex "+twinIndex+", polygonIndex "+polygonIndex);
		
		if ( !polygons.get(polygonIndex).Visible ) return true;
		else return false;
	}
	
	private void convertEdgesToIMP3d(List<Line> edgesIMP3D, List<HalfEdge> boundaryEdges, List<HalfEdge> edges, List<Vector3> vertices, Color3f color)
	{
		for ( HalfEdge edge : boundaryEdges )
		{
			Vector3 edgeStart = vertices.get(edge.VertexIndex);
			Vector3 edgeEnd = vertices.get(edges.get(edge.TwinIndex).VertexIndex);
			Vector3 edgeDirection = Vector3.minus(edgeStart, edgeEnd);
			edgeDirection.Normalize();
			edgeDirection = edgeDirection.Negated();
			
			Line line = new Line((float)edgeStart.X, (float)edgeStart.Y, (float)edgeStart.Z, (float)edgeDirection.X, (float)edgeDirection.Y, (float)edgeDirection.Z);
			line.setColor(color);
			edgesIMP3D.add(line);			
		}
	}
	
	private void convertVerticesToIMP3d(List<Point> edgesIMP3D, List<Vector3> boundaryVertices, Color3f color)
	{
		for ( Vector3 vertex : boundaryVertices )
		{
			Point point = new Point((float)vertex.X, (float)vertex.Y, (float)vertex.Z);
			point.setColor(color);
			verticesIMP3D.add(point);			
		}
	}
	
	public List<Line> getBoundaryEgdesIMP3D()
	{
		return this.edgesIMP3D;
	}
	
	public List<Point> getBoundaryVerticesIMP3D()
	{
		return this.verticesIMP3D;
	}
}